package ds;abstract IList<T>(Cell<T>) to Cell<T> from Cell<T> {    public function new() this = Cell.Nil;        public function head<T>():T {        return switch (this) {        case Nil: throw "Empty list";        case Cons(a, _): a;        }    }    public function tail<T>():IList<T> {        return switch (this) {        case Nil: throw "Empty list";        case Cons(_, t): t;        }    }    public function isEmpty():Bool {        return switch (this) {        case Nil: true;        case _: false;        }    }    /**       Create a new list with a head of ELEM       and a tail of the current list    **/    public inline function cons<T>(elem:T):IList<T> {        return Cell.Cons(elem, this);    }    /**       Create a new list contianing the       reverse of the current one    **/    public inline function reverse<T>():IList<T> {        function rev(list, acc)            return Alg.match(switch(list) {                case {[];}: acc;                case {x; xs;}: rev(xs, Cell.Cons(x, acc));                });        return rev(this, new IList());    }    /**       Create an IList from any iterable    **/    public static inline function ilist<T>(iter:Iterable<T>):IList<T> {        function loop(it):IList<T> {            return if (it.hasNext()) loop(it).cons(it.next());            else new IList();        }        return loop(iter.iterator());    }}